# -*- coding: utf-8 -*-
"""2_Pass_Assembler.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yzkAS6E29L8-DDLvzNH3LFLGAjVCCyHY
"""

def first_pass(assembly_code):
    symbol_table = {}
    address = 0
    for line in assembly_code:
        tokens = line.split()
        if tokens[0].endswith(":"):
            label = tokens[0][:-1]
            symbol_table[label] = address
            tokens.pop(0)
        address += 1
    return symbol_table
def second_pass(assembly_code, symbol_table):
    machine_code = []
    for line in assembly_code:
        tokens = line.split()
        if tokens[0].endswith(":"):
            tokens.pop(0)
        opcode = tokens[0]
        if opcode in symbol_table:
            machine_code.append(str(symbol_table[opcode]))
        else:
            machine_code.append(str(opcode))
    
    return machine_code
assembly_code = [
    "START: LDA 2",
    "STA 3",
    "LDA 5",
    "ADD 3",
    "STA 4",
    "HLT"]
symbol_table = first_pass(assembly_code)
machine_code = second_pass(assembly_code, symbol_table)
print("Symbol Table:")
for label, address in symbol_table.items():
    print(f"{label}: {address}")
print("\nMachine Code:")
for code in machine_code:
    print(code)























# Aim : Implementations of two pass Assembler.
# Theory :
# Assembly Language Syntax:
# 1. Each line of a program is one of the following:
# ● an instruction
# ● an assembler directive (or pseudo-op)
# ● a comment
# 2. Whitespace (between symbols) and case are ignored. Comments (beginning with
# “;”) are also ignored.
# 3. An instruction has the following format:
# LABEL OPCODE OPERANDS ; COMMENTS
# Example:
# ADDR1,R1,R3
# ADDR1,R1,#3
# LDR6,NUMBER
# BRzLOOP
# Schemes of translation:
# I. Two pass translation:
# ● It can handle forward reference easily.
# ● Location counter(LC) processing is done in pass 1 and the symbols defined in
# the programs are entered into the symbol table.
# ● The second pass uses this address information to generate a target program.
# II. Single pass translation:
# ● Forward reference is handled by back patching.
# 1

# Data structure of assembler
# 1. Symbol Table(ST)
# 2. Mnemonics table or Machine-Operation table (MOT).
# 3. Pseudo-opcode table (POT)
# 4. Literal table (LT)
# 5. Location counter.
# A. Symbol table:
# Symbol Value Location Length Relocation
# B. Mnemonic opcode table:
# Mnemonic Binary opcode
# C. Pseudo-opcode table (POT):
# Pseudo opcode Location of routines
# D. Literal table(LT):
# Literal Value Location
# E. IC:
# Address Opcode Operand
# ● Opcode fields:
# 1. Statement class
# 2. code
# 2
# # ● Operand-2 fields
# 1. Operand class:
# S:symbol
# L:literals
# 2. Code
# 2-Pass Assembler:
# Pass-I
# ● Separate symbol, mnemonic and operand fields.
# ● Build the symbol table.
# ● Construct intermediate code.
# Pass-II
# ● Evaluate fields and generate code.
# ● Process pseudo-opcodes.
# Algorithm:
# Pass-I
# Step1: Initialize all variables:
# Loc_cntr=0;
# Littab_ptr=0;
# Step2: Read line();
# Break-words();
# Step3: While(opcode!=end)
# Read line();
# Break-words();
# case1: if opcode=start or opcode=small model
# Loc_cntr=Value in operand field;
# Case2: if opcode=label
# 3

# Insert_symtab(label,Loc_cntr);
# Case3: if opcode=.data
# Code=search_code_MOT(opcode)
# Size=search_size_MOT(opcode)
# Loc_cntr=Loc_cntr+size;
# Generate_ic(DL,code);
# Read line();
# Break-words();
# Insert_symtab(symbol,Loc_cntr);
# Case5: else //when opcode is imperative //statement
# 1. code=search_code_MOT(opcode);
# 2. Length=search_size_MOT(opcode);
# 3. Check_operand_literal();
# If yes:
# Insert_littab(litaral,Loc_cntr)
# Littab_ptr++;
# If no:
# Find operand entry in SYMTAB
# Generate IC(IS,code)(S,entry-no);
# Loc_cntr=Loc_cntr+size;
# Case6:
# If opcode=end
# 1. code=search_code_MOT(opcode);
# 2. Length=search_size_MOT(opcode);
# 3. Loc_cntr=Loc_cntr+size;
# Step4: stop.